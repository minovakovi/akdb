# Analiza rukovanja greškama

### AK_get_array_perms() iz akdb/src/auxi/auxiliary.c

| Linije koda                                                                                       | Opis problema                                                                                                                                                             | Prijedlozi za poboljšanje                                                                                                                                                              |
|---------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `int len_arr = strlen(arr);`                                                                      | Ne provjerava se je li ulazni pokazivač `arr` jednak `NULL` prije poziva `strlen(arr)` → može doći do pada programa.                                                     | Dodati provjeru `if (arr == NULL)` i u tom slučaju vratiti `NULL` uz `AK_EPI`.                                                                                                        |
| `char *perm = (char *)AK_calloc(len_arr, sizeof(char));`                                         | Ne provjerava se rezultat alokacije memorije za `perm`.                                                                                                                  | Nakon `perm = AK_calloc(...)`, provjeriti `if (perm == NULL)` i u slučaju greške prekinuti izvođenje uz `AK_EPI`.                                                                    |
| `res_perm = (char *)AK_calloc(len_arr, sizeof(char));`                                           | Ne provjerava se rezultat alokacije memorije za `res_perm`.                                                                                                              | Provjeriti `if (res_perm == NULL)` nakon alokacije i osloboditi prethodno alociranu memoriju ako je potrebno.                                                                         |
| `res_perm = (char *)AK_calloc(num_perms, sizeof(char *));` `memcpy(res_perm, perms, sizeof(perms));` | Varijabla `res_perm` se koristi i unutar i izvan petlje s različitim značenjima → može doći do curenja memorije (gubi se referenca na prethodno alocirani blok).         | Koristiti različite varijable za rezultate unutar petlje i finalni rezultat, npr. `char **res_perms`.                                                                                 |
| `char *AK_get_array_perms(char *arr) {`                                                           | Pogrešan tip povratne vrijednosti: vraća se `char*`, ali se zapravo vraća pokazivač na niz stringova.                                                                    | Promijeniti povratni tip funkcije u `char **` kako bi odgovarao stvarnoj strukturi podataka koja se vraća.                                                                            |
| `for (next_perm = 0; next_perm < num_perms; next_perm++) { … perms[next_perm] = res_perm; … }`   | Nema čišćenja prethodno alociranih `perms[i]` ako dođe do greške u kasnijoj iteraciji.                                                                                    | Dodati petlju koja oslobađa sve prethodno alocirane `perms[i]` u slučaju prekida petlje zbog greške.                                                                                  |


### AK_debmod_signal_callback() iz akdb/src/auxi/mempro.c

| Linije koda                                                                      | Opis problema                                                                                                                                                             | Prijedlozi za poboljšanje                                                                                                                                                              |
|----------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `printf(...)` pozivi u slučaju `sigsegv`                                         | Korištenje `printf` je nesigurno kod rukovanja signalima.                                                                                                                | Koristiti sigurne funkcije za ispis unutar signal `handlera` (npr. `write` na `STDERR_FILENO`) ili postaviti `flag` koji će se naknadno obrađivati u glavnom dijelu programa izvan `handlera`. |
| `AK_DEBMOD_STATE->fstack_items[AK_DEBMOD_STATE->fstack_size - 1]`             | Pristup `fstack_size - 1` bez provjere da je `fstack_size > 0` može dovesti do pristupa nevažećoj memoriji ako je stog prazan.                                       | Dodati provjeru `if (AK_DEBMOD_STATE->fstack_size > 0)` prije pristupa elementu stoga. Ako je stog prazan, ispisati odgovarajuću poruku ili postaviti `placeholder` vrijednost.       |
| `if(mprotect_sigsegv == 0) { ... assert(mprotect_sigsegv); }`                     | Korištenje `asserta` za prekid programa nije najbolje rješenje.                                                                                                           | Umjesto `asserta` koristiti poruke o grešci ili poslati signal procesu da se zaustavi.                                                                                                |

### AK_print_index_table() iz akdb/src/file/idx/index.c

| Linije koda                                                              | Opis problema                                                                                                                                                                                                                                                                                                                                                          | Prijedlozi za poboljšanje                                                                                                                                                                        |
|--------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `U petlji while (addresses->address_from[i] != 0)`                       | Ne provjerava je li indeks `i` unutar granica `addresses` strukture → moguće pristupanje neinicijaliziranim ili nevalidnim adresama.                                                                                                                                                                                                             | Dodati provjeru granica ili jasnije definirati veličinu niza `addresses`.                                                                                                          |
| `struct list_node *el = AK_get_index_tuple(i, indexTblName);`            | Ne provjerava se je li `el` `NULL` → u slučaju da je `NULL`, dereferenciranje će izazvati grešku.                                                                                                                                                                                                                                                              | Dodati provjeru `if (el == NULL)` i ako je `NULL`, obraditi grešku.                                                                                                                    |
| `table_addresses *addresses = (table_addresses*)AK_get_index_addresses(indexTblName);` | Ne provjerava se je li `addresses` `NULL` nakon poziva funkcije.                                                                                                                                                                                                                                                                                                                            | Dodati provjeru `if (addresses == NULL)` i obraditi grešku.                                                                                                                           |
| `AK_mem_block *temp = (AK_mem_block*)AK_get_block(j);`                   | Nema provjere da li je `temp` `NULL` → dereferenciranje u sljedećim linijama može izazvati rušenje programa.                                                                                                                                                                                                                               | Dodati provjeru `if (temp == NULL)` i ako je `NULL`, obraditi grešku.                                                                                                                    |
| `struct list_node *row_root = (struct list_node *)AK_malloc(sizeof(struct list_node));` | Nema provjere je li alokacija uspješna (`NULL` provjera).                                                                                                                                                                                                                                                                                                     | Dodati provjeru `if (row_root == NULL)` nakon `AK_malloc`. Ako je `NULL`, obraditi grešku.                                                                                             |

### AK_aggregation() iz akdb/src/rel/aggregation.c

| Linije koda                                                                                                        | Opis problema                                                                                                                                                                                                                                                                                              | Prijedlozi za poboljšanje                                                                                                                                                                                                                                                          |
|--------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `AK_agg_value *needed_values = AK_malloc(sizeof(AK_agg_value) * num_aggregations);`                                | Nema provjere je li `AK_malloc` uspješno alocirao memoriju -> ako nije, kasnija dereferenciranja će dovesti do rušenja.                                                                                                                                                                             | Dodati provjeru `if (needed_values == NULL)`                                                                                                                                                                                                                          |
| `int startAddress = AK_initialize_new_segment(new_table, SEGMENT_TYPE_TABLE, agg_head);`                           | Iako se ispisuje poruka o grešci ako `startAddress == EXIT_ERROR`, daljnji kod (`AK_get_table_addresses`, `AK_read_block_itd.`) može ovisiti o uspješnoj inicijalizaciji. Funkcija nastavlja s radom čak i ako stvaranje tablice ne uspije.                                                           | Prekinuti izvršavanje: Ako `startAddress == EXIT_ERROR`, funkcija bi trebala osloboditi sve alocirane resurse i odmah vratiti `EXIT_ERROR`.                                                                                                                        |
| `rowroot_struct rowroot_table = { .row_root = (struct list_node*)AK_malloc(sizeof(struct list_node)) }; AK_Init_L3(&rowroot_table);` | Nema provjere uspjeha `AK_malloc` za `row_root`. Ako alokacija ne uspije, `rowroot_table.row_root` će biti `NULL`.                                                                                                                                                                          | Nakon `AK_malloc`, provjeriti je li alokacija uspjela. Ako ne, osloboditi sve prethodne resurse i vratiti `EXIT_ERROR`.                                                                                                                                             |
| `AK_agg_input *input, char *source_table, char *agg_table`                                                        | Nema provjere za `NULL` vrijednosti `input`, `source_table`, `agg_table`.                                                                                                                                                                                                                            | Dodati provjeru za `NULL` vrijednosti `input`, `source_table`, `agg_table`.                                                                                                                                                                                          |

### AK_get_memory_blocks() iz akdb/src/trans/transaction.c

| Linije koda                                                                                                        | Opis problema                                                                                                                                                             | Prijedlozi za poboljšanje                                                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `if (addresses->address_from[0] == 0)`                                                                               | Dereferencira se `addresses` bez prethodne provjere da nije `NULL`.                                                                                                       | Prvo provjeriti `if (addresses == NULL)`.                                                                                                                                              |
| `if (addressList->nextElement != NULL) { addressList->nextElement = NULL; }`                                         | Resetira `nextElement` bez oslobađanja memorije prethodno alociranih elemenata – curenje memorije.                                                                       | Prije resetiranja osloboditi memoriju cijele liste iza `addressList->nextElement`.                                                                                                     |
| `tmp->nextElement = (AK_memoryAddresses_link)AK_malloc(sizeof(struct memoryAddresses));`                            | Ne provjerava se je li `AK_malloc` uspio (može vratiti `NULL`).                                                                                                            | Nakon `AK_malloc` dodati provjeru: `if (tmp->nextElement == NULL)`.                                                                                                                    |
| `table_addresses *addresses = (table_addresses*)AK_get_table_addresses(tblName);`                                   | Ne provjerava se je li `addresses` `NULL` prije pristupa njegovim članovima.                                                                                             | Dodati provjeru `if (addresses == NULL)`.                                                                                                                                              |
| `for (j = addresses->address_from[i]; j < addresses->address_to[i]; j++) {`                                         | Varijabla `i` je stalno 0, nema kontrole da ne izlazi iz granica ili petlje preko svih adresa.                                                                            | Dodati petlju za iteriranje kroz sve indekse i dok `address_from[i] != 0`.                                                                                                          |

### AK_insert() iz akdb/src/sql/insert.c

| Linije koda                                                                                   | Opis problema                                                                                                                                                                                                                                                                                           | Prijedlozi za poboljšanje                                                                                                                                                                                                                                   |
|-----------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `if(num_values % num_columns) { AK_free(header); AK_EPI; return EXIT_ERROR; }`                | Ne provjerava je li `num_columns` 0 →  može dovesti do dijeljenja s nulom.                                                                                                                                                                                                                            | Dodati provjeru `if (num_columns == 0)`                                                                                                                                                                                                             |
| `row = (struct list_node *)AK_malloc(sizeof(struct list_node)); AK_Init_L3(&row);`           | Nema provjere je li `AK_malloc` uspio (može vratiti `NULL`).                                                                                                                                                                                                                                       | Dodati provjeru `if (row == NULL)`                                                                                                                                                                                                                   |
| `AK_header *header = AK_get_insert_header(&num_columns, tblName, columns); if(header == EXIT_ERROR) { ... }` | `AK_get_insert_header` vraća `EXIT_ERROR` koji se uspoređuje s pointerom `header` - potencijalno pogrešno.                                                                                                                                                                                           | Bolje da funkcija `AK_get_insert_header` vraća `NULL` u slučaju greške; dodati provjeru `if (header == NULL)`.                                                                                                                                     |

### AK_reference_update() iz akdb/src/sql/cs/reference.c

| Linije koda                                                                                                          | Opis problema                                                                                         | Prijedlozi za poboljšanje                                                                 |
|----------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------|
| `struct list_node *row_root = (struct list_node *)AK_malloc(sizeof(struct list_node)); AK_Init_L3(&row_root);` | Nema provjere je li `AK_malloc` uspio (može vratiti `NULL`).                                 | Dodati provjeru: `if (row_root == NULL)`                                               |
| `memcpy(tempData, tempcell->data, tempcell->size); tempData[tempcell->size] = '\0';`                                | Ne provjerava se je li `tempcell` `NULL` prije pristupa `tempcell->data` i `tempcell->size`. | Provjeriti `if (tempcell == NULL)`                                                         |
| `memcpy(tempData, tempcell->data, tempcell->size); tempData[tempcell->size] = '\0';`                                | Ako `tempcell->size` premašuje `MAX_VARCHAR_LENGTH - 1`, doći će do prelijevanja `tempData` buffera. | Provjeriti veličinu: `if (tempcell->size >= MAX_VARCHAR_LENGTH)`                         |
| `while ((parent_row = AK_get_row(parent_i, tempTable)) != NULL) { ... parent_i++; }`                                | Nema inicijalizacije `parent_i` prije petlje.                                                 | Inicijalizirati `parent_i = 0;` prije petlje.                                              |
| `while ((ref_row = AK_get_row(ref_i, "AK_reference")) != NULL) { ... ref_i++; }`                                   | Nema inicijalizacije varijable `ref_i` prije petlje.                                           | Inicijalizirati `ref_i = 0;` prije petlje.                                                 |

### AK_create_Index_Table() iz akdb/src/file/idx/bitmap.c

| Linije koda                                                              | Opis problema                                                                                                                              | Prijedlozi za poboljšanje                                                                                                                                                                                                                                                         |
|--------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `addresses = (table_addresses*)AK_get_table_addresses(tblName);`         | Nema provjere je li `addresses` == `NULL` → može dovesti do dereferenciranja `NULL` pokazivača.                                          | Dodati provjeru: `if (addresses == NULL)`                                                                                                                                                                                                                          |
| `temp_head = (AK_header*)AK_get_header(tblName);`                       | Ne provjerava se je li `temp_head` `NULL` -> može doći do `segfault`.                                                                     | Dodati provjeru: `if (temp_head == NULL)`                                                                                                                                                                                                                          |
| `headerAttributes = (struct list_node *)AK_malloc(sizeof(struct list_node));` | Nema provjere je li uspjela alokacija memorije.                                                                                             | Dodati provjeru: `if (headerAttributes == NULL)`                                                                                                                                                                                                                 |
| `if (startAddress != EXIT_ERROR) { printf("INDEX %s CREATED!\n", indexName); AK_create_Index(tblName, indexName, (temp_head + i)->att_name, i, num_attr, t_header); } break;` | Nema eksplicitnog ispisa greške kad `startAddress == EXIT_ERROR`, što bi pomoglo pri `debuggingu`. | Dodati ispis greške, na primjer: `else printf("Greška pri inicijalizaciji indeksa: %s\n", indexName);` |

### AK_find_delete_in_hash_index() iz akdb/src/file/idx/hash.c

| Linije koda                                                                                                     | Opis problema                                                                                                                                                                                                                                                                                  | Prijedlozi za poboljšanje                                                                                                                                                                                                                                    |
|-----------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `struct add *add = (struct add*)AK_malloc(sizeof(struct add));`                                                 | Nema provjere je li `AK_malloc` vratio `NULL`.                                                                                                                                                                                                                                       | Dodati provjeru nakon alokacije: `if (add == NULL)` i ako je `NULL`, obraditi grešku.                                                                                                                                                                                                                          |
| `memcpy(temp_main_bucket, &temp_block->data[address], size);`                                                   | Nema provjere je li `address + size` unutar granica `data`.                                                                                                                                                                                                                            | Dodati provjeru da je `address + size <= veličina bloka`, kako bi se spriječio preljev međuspremnika.                                                                                                                                                                                                            |
| `if (temp_elem->type == record_type && memcmp(data, temp_elem->data, record_size) == 0)`                        | Nema provjere je li `record_size` veći od `sizeof(data)(255)` ili je li `temp_elem->data` dovoljno veličine - može doći do preljeva međuspremnika.                                                                                                                                         | Osigurati da `record_size` ne prelazi veličinu `data` međuspremnika; provjeriti da `temp_elem->data` ima dovoljnu veličinu za `record_size`.                                                                                                                                                                                                                                                |
| `address = temp_block->tuple_dict[main_add->indexTd].address; i = temp_block->tuple_dict[main_add->indexTd].size;` | Nema provjere granica za `main_add->indexTd`. Ako je indeks izvan granica `temp_block->tuple_dict`, može dovesti do čitanja izvan dodijeljene memorije. | Dodati provjeru granica za `main_add->indexTd` prije pristupa `temp_block->tuple_dict`.                                                                                                                                                                                                                         |

### AK_print_table() iz akdb/src/file/table.c

| Linije koda                                                                      | Opis problema                                                                                                                                                             | Prijedlozi za poboljšanje                                                                                                                                                              |
|----------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `temp[0] = (AK_mem_block*)AK_get_block(j);`                    | Nema provjere je li `AK_get_block(j)` vratio `NULL` → dereferenciranje `temp[0]->block` bi moglo srušiti program.                                                    | Dodati provjeru `if (temp[0] == NULL)` i ispisati grešku.                                                                                                                              |
| `AK_header *head = AK_get_header(tblName);`                                    | Ne provjerava se je li `head` `NULL` → može dovesti do dereferenciranja `NULL` pokazivača `(head + i)->att_name`.                                                 | Dodati provjeru `if (head == NULL)` nakon poziva.                                                                                                                                      |
| `int len[num_attr];`                                                            | Ako `num_attr <= 0`, tada se alocira niz s nulom elemenata.                                                                                                                | Dodati provjeru `if (num_attr <= 0)` i izaći iz funkcije s odgovarajućom porukom.                                                                                                      |
| `struct list_node *el = AK_get_tuple(j, i, tblName);`                          | Ako `AK_get_tuple` vrati `NULL`, `el->type` bi uzrokovao `segmentation fault`.                                                                                            | Dodati provjeru `if (el == NULL)` i ispisati odgovarajuću grešku, preskočiti iteraciju.                                                                                                |
| `struct list_node *row_root = (struct list_node *)AK_malloc(sizeof(struct list_node));` | Nema provjere je li `AK_malloc` vratio `NULL` → `row_root` može biti `NULL`.                                                                                             | Provjeriti je li `row_root` `NULL` nakon poziva `AK_malloc`.                                                                                                                           |

### AK_difference() iz akdb/src/rel/difference.c

| Linije koda                                                                                                        | Opis problema                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Prijedlozi za poboljšanje                                                                                                                                                                                                                                                          |
|--------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `if((startAddress1 != 0) && (startAddress2 != 0))`                                                                 | Provjerava samo jesu li početne adrese različite od nule, što implicira da tablica postoji. Međutim, `AK_get_table_addresses` može vratiti `NULL` ako tablice ne postoje, a `src_addr1` i `src_addr2` se ne provjeravaju prije pristupa `address_from[0]` -> može dovesti do dereferenciranja `NULL` pokazivača.                                                                                                                                               | Dodati provjeru jesu li `src_addr1` i `src_addr2` `NULL` i ako jesu, osloboditi sve alocirane resurse i odmah vratiti `EXIT_ERROR`.                                                                                                                                                                                                                                                         |
| `AK_Insert_New_Element` i `AK_insert_row`                                                                          | Nema provjera povratnih vrijednosti ovih funkcija → neuspješno umetanje elemenata ili redova može dovesti do curenja memorije.                                                                                                                                                                                                                                                                                                                                    | Dodati provjeru povratnih vrijednosti funkcija `AK_Insert_New_Element` i `AK_insert_row`.                                                                                                                                                                                           |
| `else { AK_dbg_messg(LOW, REL_OP, "AK_difference: Table/s doesn't exist"); ... }`                                   | Nije jasno koja od tablica nedostaje.                                                                                                                                                                                                                                                                                                                                                                                                                                    | Specificirati koja točno tablica ne postoji.                                                                                                                                                                                                                                       |
| `if (tbl1_temp_block->block->tuple_dict[m + 1].type == FREE_INT)`                                                  | Ne provjerava se izlazak iz granica u `tuple_dict[m + 1]`.                                                                                                                                                                                                                                                                                                                                                                                                        | Dodati provjeru da `m + 1 < DATA_BLOCK_SIZE`. Također i za `n + 1`.                                                                                                                                                                                                            |

### AK_grant_privilege_user() iz akdb/src/sql/privileges.c

| Linije koda                                                                                                        | Opis problema                                                                                                                                                                                                                                                                                           | Prijedlozi za poboljšanje                                                                                                                                                                                                                                   |
|--------------------------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `struct list_node *row_root = (struct list_node *)AK_malloc(sizeof(struct list_node));`                            | Nedostaje provjera povratne vrijednosti `AK_malloc` → `row_root` može biti `NULL` → pad programa.                                                                                                                                                                                                     | Provjeriti je li pokazivač `row_root` `NULL` nakon `AK_malloc` i na temelju toga vratiti grešku ili pokušati ponovno.                                                                                                                                         |
| `AK_insert_row(row_root);`                                                                                         | Nema provjere uspješnosti umetanja retka u bazu/tablicu.                                                                                                                                                                                                                                              | Dodati provjeru uspješnosti `AK_insert_row`. U slučaju neuspjeha, osloboditi resurse i vratiti `EXIT_ERROR`.                                                                                                                                         |
| `strcpy(privileges, &rights[0], "UPDATE\0");`                                                                      | Kopiranje stringova u fiksno polje bez provjere granica → može biti nesigurno ako se promijene duljine prava.                                                                                                                                                                                          | Korištenje sigurnijih funkcija poput `strncpy`.                                                                                                                                                                                                                      |
| `printf("\nGranted privilege to %s data for user %s under ID %d on table %s!\n\n", username, user_id, table);`     | Poruka se ispisuje bez obzira na to je li operacija uspješna izvršena. Ako `AK_insert_row` ne uspije, korisnik će dobiti netočnu informaciju da je privilegija dodijeljena. | Poruka o uspjehu trebala bi se ispisati tek nakon što su sve operacije uspješno završene. Ako je bilo koja podoperacija neuspješna, treba ispisati poruku o grešci.                                                                                               |

### AK_trigger_add() iz akdb/src/sql/trigger.c

| Linije koda | Opis problema | Prijedlozi za poboljšanje |
|---|---|---|
| `return trig_id;` | Funkcija vraća `trigg_id` iako je moglo doći do grešaka u kasnijim operacijama bez provjere. | Funkcija bi trebala vratiti `trigg_id` samo ako je svaki korak dodavanja okidača bio u cijelosti uspješan. U suprotnom, treba vratiti `EXIT_ERROR`. |
| `AK_Insert_New_Element(...)` | Nema provjere uspješnosti unosa elemenata u listu. | Provjeriti povratne vrijednosti `AK_Insert_New_Element` i obraditi potencijalne greške. |
| `AK_insert_row(row_root);` | Nema provjere uspješnosti umetanja retka u bazu/sustav. | Provjeriti rezultat `AK_insert_row`. U slučaju greške vratiti `EXIT_ERROR` i osloboditi memoriju. |
| `AK_trigger_save_conditions(trigg_id, condition);` | Nema provjere uspješnosti spremanja uvjeta okidača. | Provjerite povratnu vrijednost funkcije `AK_trigger_save_conditions` i obraditi moguće greške. |

### AK_query_optimization() iz akdb/src/opti/query_optimization.c

| Linije koda | Opis problema | Prijedlozi za poboljšanje |
|---|---|---|
| `struct list_node *temp = (struct list_node *)AK_malloc(sizeof(struct list_node));` | Nema provjere je li alokacija memorije uspješna (`temp == NULL`). | Provjeriti vraća li `AK_malloc` `NULL` i u slučaju greške vratiti `EXIT_ERROR` ili odgovarajuću vrijednost. |
| `char *record = AK_get_relation_expression(list_elem->data); strcpy(list_elem->data, record);` | `AK_get_relation_expression` može vratiti `NULL` → `strcpy` će pokušati kopirati iz `NULL` pokazivača, što dovodi do pada programa. | Provjeriti `record != NULL` prije `strcpy`. |
| `struct list_node *temps[num_perms];` | Nema provjere uspješnosti alokacije memorije za niz pokazivača `temps`. | Provjeriti maksimalnu veličinu i ograničiti `num_perms` prije deklaracije ili dinamički alocirati niz. |
| `temps[next_perm] = (struct list_node *)AK_malloc(sizeof(struct list_node));` | Nema provjere uspješnosti alokacije memorije. | Provjeriti `NULL` i u slučaju greške osloboditi prethodno alocirane memorije te prekinuti s odgovarajućom greškom. |
| `temp = (struct list_node *)AK_realloc(temp, num_perms * sizeof(temps));` | Korištenje `AK_realloc` bez provjere uspješnosti. | Provjeriti je li `temp == NULL` nakon realokacije i po potrebi osloboditi memoriju i vratiti grešku. |

### AK_add_to_redolog() iz akdb/src/rec/redo_log.c

| Linije koda | Opis problema | Prijedlozi za poboljšanje |
|---|---|---|
| `if (redoLog == NULL) return EXIT_FAILURE;` | Provjera postoji, ali nema objašnjenja zašto funkcija ne može nastaviti. | Dodati ispis greške. |
| `memcpy(&table, el->table, strlen(el->table));` | Ne provjerava veličinu `el->table`, može doći do preljeva međuspremnika jer se ne koristi sigurnija funkcija. | Koristiti `strncpy`. |
| `char* attrs = AK_calloc(attrs_length, sizeof(char*));` | Nema provjere je li `attrs` uspješno alociran -> može biti `NULL`. | Provjeriti `attrs == NULL` i ako je, osloboditi `record` i vratiti grešku. |
| `strncat(record, ...)` | Višestruki pozivi `strncat` bez provjere ukupne veličine `record` mogu dovesti do preljeva međuspremnika. | Voditi evidenciju preostalog slobodnog prostora u `record` i koristiti `strncat` ili `snprintf` s ograničenom duljinom. |
| `for(i=0; i<numAttr-1; i++) strcpy(redoLog->command_recovery[n].arguments[i], attrs[i]);` | Nema provjere veličine međuspremnika `arguments[i]`, što može uzrokovati `buffer overflow`. | Provjeriti veličine prije kopiranja ili koristiti `strncpy` s ograničenom veličinom `arguments[i]`. |

### AK_set_constraint_unique() iz akdb/src/sql/cs/unique.c

| Linije koda | Opis problema | Prijedlozi za poboljšanje |
|---|---|---|
| `row = AK_get_row(0, tableName);` | U slučaju da `AK_get_row` vrati `NULL`, funkcija nastavlja s korištenjem pokazivača `row` → može dovesti do `segmentation fault`-a. | Dodati provjeru `if(row == NULL)` nakon poziva i prekinuti izvršavanje s odgovarajućom porukom o grešci. |
| `AK_insert_row(row_root);` | Ne provjerava se povratna vrijednost `AK_insert_row(row_root)`. | Provjeriti povratnu vrijednost `AK_insert_row()` i obraditi moguće greške. |
| `tuple_to_string_return = AK_tuple_to_string(attribute); if(tuple_to_string_return==NULL)` | Ako `tuple_to_string` vrati `NULL`, to može ukazivati na nevaljan podatak, ali se ne vraća greška, samo se prekida usporedba. | Dodati ispis pogreške i potencijalno logirati koji atribut je uzrokovao problem. |
| `if(uniqueConstraintName == EXIT_ERROR)` | Ne postoji detalj zašto je došlo do pogreške. | Dodati detaljnije poruke za korisnika. |

### AK_get_allocation_set() iz akdb/src/dm/dbman.c

| Linije koda | Opis problema | Prijedlozi za poboljšanje |
|---|---|---|
| `if (gaplength < 1) gaplength = 1;` | Nije jasno dokumentirano niti se korisniku javlja greška. | Logirati upozorenje ili vratiti grešku ako je `gaplength` nevaljan kako bi se korisnik obavijestio. |
| `if ((i + 1) == num_free_blocks_bitmap)` u `allocationAROUND` | Provjerava samo jednu vrijednost, ne pokriva situaciju kad `target` nije pronađen. | Dodati logičku provjeru ako `target` nije nigdje u `freeBlocksMap`, npr. `if ((i == num_free_blocks_bitmap)` i obraditi pogrešku. |
| `return allocationSet[0];` | Funkcija uvijek vraća `allocationSet[0]` i u slučaju pogreške i uspjeha. | Omogućiti razlikovanje povratnih vrijednosti za uspjeh i pogrešku. |
| `int* allocationSet` | Nema provjere je li `allocationSet` `NULL` → može doći do dereferenciranja `NULL` pokazivača i pada programa. | Dodati provjeru `if (allocationSet == NULL)` na početak funkcije. |

### AK_btree_create() iz akdb/src/file/idx/btree.c

| Linije koda                                                                                     | Opis problema                                                                                                                                                     | Prijedlozi za poboljšanje                                                                                                                                              |
|-------------------------------------------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `while(addresses->address_from[ i ]){...}`                                                        | Varijabla `i` nije inicijalizirana prije petlje.                                                                                                                    | Dodati `i = 0;` prije while petlje.                                                                                                                                       |
| `temp = (AK_header*) AK_create_header(...)`                                                       | Ne provjerava se je li temp `NULL` prije `memcpy`.                                                                                                                    | Dodati provjeru: `if (temp == NULL) return NULL;`.                                                                                                                       |
| `memcpy(tem, &(temp->data[temp->tuple_dict[help].address]), sizeof (int));`                      | Nema provjere je li `help` unutar granica `tuple_dict`.                                                                                                               | Dodati provjeru granica za `help`.                                                                                                                                       |
| `memcpy(block->data, rootEl, sizeof(root_info));`                                                 | Nedostaje provjera je li `block->data NULL` i je li ima dovoljno alociranog prostora za `root_info`.                                                                 | Provjeriti da je `block->AK_free_space + sizeof(root_info)` unutar granica alociranog buffera za `block->data`.                                                           |

### AK_search_unsorted() iz akdb/src/file/filesearch.c

| Linije koda                                                                                                                      | Opis problema                                                                                                                                                                                                      | Prijedlozi za poboljšanje                                                                                                                                                                  |
|----------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `if (srResult.iNum_search_attributes != iNum_search_params) return srResult;`                                                      | Vraća se prazan rezultat bez objašnjenja ako neki atribut nije pronađen.                                                                                                   | Dodati poruku upozorenja o nepostojanju atributa.                                                                                                                                          |
| `taAddresses = AK_get_table_addresses(szRelation);`                                                                                | Nema provjere povratne vrijednosti `AK_get_table_addresses`.                                                                                                                 | Nakon poziva `AK_get_table_addresses`, provjerite je li `taAddresses NULL` → ako je, obraditi grešku.                                                                                        |
| `if (!strcmp(mem_block->block->header[i].att_name, aspParams[j].szAttribute))`                                                    | Nedostaje provjera je li `mem_block->block->header[i].att_name NULL` ili je li `aspParams[j].szAttribute NULL`. Pozivanje strcmp s `NULL` argumentom rezultira padom programa. Također, nema provjere je li `i` unutar granica `mem_block->block->header`. | Provjeriti da su oba stringa validna prije poziva `strcmp`. Provjeriti da `i` ne prelazi `MAX_ATTRIBUTES` ili stvarni broj atributa.                                                             |

### AK_sort_segment() iz akdb/src/file/filesort.c

| Linije koda                                                | Opis problema                                                                                                                                                      | Prijedlozi za poboljšanje                                                                                                                           |
|------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------|
| `table_addresses *addresses = (table_addresses *) AK_get_table_addresses(srcTable);` | Ne provjerava se povratna vrijednost funkcije `AK_get_table_addresses` → ako je  `srcTable  `pogrešan ili tablica ne postoji, može doći do dereferenciranja `NULL` pokazivača. | Dodati provjeru: `if (addresses == NULL)` i obradu mogućih greški.                                                                                    |
| `AK_header *head = AK_get_header(srcTable);`                 | Nema provjere je li `head NULL` → može dovesti do problema ako ne postoji zaglavlje tablice.                                                                      | Dodati provjeru `if (head == NULL)`.                                                                                                                  |
| `for (i = 0; i<num_records; i++) { temp_field[i]=i; }`        | Nema provjere je li `num_records` veći od `MAX_NUM_OF_BLOCKS`, što može dovesti do prekoračenja niza `temp_field`.                                                     | Dodati provjeru da `num_records <= MAX_NUM_OF_BLOCKS` ili proširiti `temp_field` ako treba podržati veće vrijednosti.                                  |
| `memcpy(x, real_table->block->data + address, size);`         | Nema provjere granica kod `memcpy`, `address + size` može izaći izvan granica podatkovnog bloka.                                                                     | Dodati provjeru da `address + size <= veličina bloka`.                                                                                               |
